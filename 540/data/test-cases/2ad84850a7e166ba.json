{
  "uid" : "2ad84850a7e166ba",
  "name" : "A.29 DELETE Активировать и удалить авторизованного пользователя",
  "fullName" : "tests.api_tests.api_test.TestAPI#test_delete_auth_users_me_new",
  "historyId" : "6a41cf7d2d151c49a148ff90484bf042",
  "time" : {
    "start" : 1760346127845,
    "stop" : 1760346161118,
    "duration" : 33273
  },
  "status" : "broken",
  "statusMessage" : "ConnectionResetError: [Errno 104] Connection reset by peer",
  "statusTrace" : "cls = <class 'ssl.SSLSocket'>\nsock = <socket.socket [closed] fd=-1, family=2, type=1, proto=6>\nserver_side = False, do_handshake_on_connect = True, suppress_ragged_eofs = True\nserver_hostname = 'imap.mail.ru'\ncontext = <ssl.SSLContext object at 0x7f5ae19f76d0>, session = None\n\n    @classmethod\n    def _create(cls, sock, server_side=False, do_handshake_on_connect=True,\n                suppress_ragged_eofs=True, server_hostname=None,\n                context=None, session=None):\n        if sock.getsockopt(SOL_SOCKET, SO_TYPE) != SOCK_STREAM:\n            raise NotImplementedError(\"only stream sockets are supported\")\n        if server_side:\n            if server_hostname:\n                raise ValueError(\"server_hostname can only be specified \"\n                                 \"in client mode\")\n            if session is not None:\n                raise ValueError(\"session can only be specified in \"\n                                 \"client mode\")\n        if context.check_hostname and not server_hostname:\n            raise ValueError(\"check_hostname requires server_hostname\")\n    \n        sock_timeout = sock.gettimeout()\n        kwargs = dict(\n            family=sock.family, type=sock.type, proto=sock.proto,\n            fileno=sock.fileno()\n        )\n        self = cls.__new__(cls, **kwargs)\n        super(SSLSocket, self).__init__(**kwargs)\n        sock.detach()\n        # Now SSLSocket is responsible for closing the file descriptor.\n        try:\n            self._context = context\n            self._session = session\n            self._closed = False\n            self._sslobj = None\n            self.server_side = server_side\n            self.server_hostname = context._encode_hostname(server_hostname)\n            self.do_handshake_on_connect = do_handshake_on_connect\n            self.suppress_ragged_eofs = suppress_ragged_eofs\n    \n            # See if we are connected\n            try:\n>               self.getpeername()\nE               OSError: [Errno 107] Transport endpoint is not connected\n\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/ssl.py:992: OSError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_tests.api_test.TestAPI object at 0x7f5ae339c830>\nuse_api_base = <api_testing.api_base.ApiBase object at 0x7f5ae33fb4d0>\n\n    @allure.title(\"A.29 DELETE Активировать и удалить авторизованного пользователя\")\n    def test_delete_auth_users_me_new(self, use_api_base):\n        url = f'{self.link.BASE_URL}auth/users/activation/'\n>       user_token = use_api_base.get_tokens_on_email(email1, password1, 'activate/')\n\ntests/api_tests/api_test.py:294: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \napi_testing/api_base.py:69: in get_tokens_on_email\n    msg = self.read_email(my_email, my_password)\napi_testing/api_base.py:54: in read_email\n    mail = imaplib.IMAP4_SSL('imap.mail.ru')\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/imaplib.py:1315: in __init__\n    IMAP4.__init__(self, host, port, timeout)\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/imaplib.py:205: in __init__\n    self.open(host, port, timeout)\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/imaplib.py:1328: in open\n    IMAP4.open(self, host, port, timeout)\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/imaplib.py:315: in open\n    self.sock = self._create_socket(timeout)\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/imaplib.py:1319: in _create_socket\n    return self.ssl_context.wrap_socket(sock,\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/ssl.py:455: in wrap_socket\n    return self.sslsocket_class._create(\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/ssl.py:1004: in _create\n    notconn_pre_handshake_data = self.recv(1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ssl.SSLSocket [closed] fd=-1, family=2, type=1, proto=6>, buflen = 1\nflags = 0\n\n    def recv(self, buflen=1024, flags=0):\n        self._checkClosed()\n        if self._sslobj is not None:\n            if flags != 0:\n                raise ValueError(\n                    \"non-zero flags not allowed in calls to recv() on %s\" %\n                    self.__class__)\n            return self.read(buflen)\n        else:\n>           return super().recv(buflen, flags)\nE           ConnectionResetError: [Errno 104] Connection reset by peer\n\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/ssl.py:1234: ConnectionResetError",
  "flaky" : false,
  "newFailed" : false,
  "beforeStages" : [ {
    "name" : "_session_faker",
    "time" : {
      "start" : 1760326821367,
      "stop" : 1760326821382,
      "duration" : 15
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "use_api_base",
    "time" : {
      "start" : 1760346127844,
      "stop" : 1760346127844,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "clear_allure_result_folder",
    "time" : {
      "start" : 1760326821383,
      "stop" : 1760326821383,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  } ],
  "testStage" : {
    "status" : "broken",
    "statusMessage" : "ConnectionResetError: [Errno 104] Connection reset by peer",
    "statusTrace" : "cls = <class 'ssl.SSLSocket'>\nsock = <socket.socket [closed] fd=-1, family=2, type=1, proto=6>\nserver_side = False, do_handshake_on_connect = True, suppress_ragged_eofs = True\nserver_hostname = 'imap.mail.ru'\ncontext = <ssl.SSLContext object at 0x7f5ae19f76d0>, session = None\n\n    @classmethod\n    def _create(cls, sock, server_side=False, do_handshake_on_connect=True,\n                suppress_ragged_eofs=True, server_hostname=None,\n                context=None, session=None):\n        if sock.getsockopt(SOL_SOCKET, SO_TYPE) != SOCK_STREAM:\n            raise NotImplementedError(\"only stream sockets are supported\")\n        if server_side:\n            if server_hostname:\n                raise ValueError(\"server_hostname can only be specified \"\n                                 \"in client mode\")\n            if session is not None:\n                raise ValueError(\"session can only be specified in \"\n                                 \"client mode\")\n        if context.check_hostname and not server_hostname:\n            raise ValueError(\"check_hostname requires server_hostname\")\n    \n        sock_timeout = sock.gettimeout()\n        kwargs = dict(\n            family=sock.family, type=sock.type, proto=sock.proto,\n            fileno=sock.fileno()\n        )\n        self = cls.__new__(cls, **kwargs)\n        super(SSLSocket, self).__init__(**kwargs)\n        sock.detach()\n        # Now SSLSocket is responsible for closing the file descriptor.\n        try:\n            self._context = context\n            self._session = session\n            self._closed = False\n            self._sslobj = None\n            self.server_side = server_side\n            self.server_hostname = context._encode_hostname(server_hostname)\n            self.do_handshake_on_connect = do_handshake_on_connect\n            self.suppress_ragged_eofs = suppress_ragged_eofs\n    \n            # See if we are connected\n            try:\n>               self.getpeername()\nE               OSError: [Errno 107] Transport endpoint is not connected\n\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/ssl.py:992: OSError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.api_tests.api_test.TestAPI object at 0x7f5ae339c830>\nuse_api_base = <api_testing.api_base.ApiBase object at 0x7f5ae33fb4d0>\n\n    @allure.title(\"A.29 DELETE Активировать и удалить авторизованного пользователя\")\n    def test_delete_auth_users_me_new(self, use_api_base):\n        url = f'{self.link.BASE_URL}auth/users/activation/'\n>       user_token = use_api_base.get_tokens_on_email(email1, password1, 'activate/')\n\ntests/api_tests/api_test.py:294: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \napi_testing/api_base.py:69: in get_tokens_on_email\n    msg = self.read_email(my_email, my_password)\napi_testing/api_base.py:54: in read_email\n    mail = imaplib.IMAP4_SSL('imap.mail.ru')\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/imaplib.py:1315: in __init__\n    IMAP4.__init__(self, host, port, timeout)\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/imaplib.py:205: in __init__\n    self.open(host, port, timeout)\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/imaplib.py:1328: in open\n    IMAP4.open(self, host, port, timeout)\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/imaplib.py:315: in open\n    self.sock = self._create_socket(timeout)\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/imaplib.py:1319: in _create_socket\n    return self.ssl_context.wrap_socket(sock,\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/ssl.py:455: in wrap_socket\n    return self.sslsocket_class._create(\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/ssl.py:1004: in _create\n    notconn_pre_handshake_data = self.recv(1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ssl.SSLSocket [closed] fd=-1, family=2, type=1, proto=6>, buflen = 1\nflags = 0\n\n    def recv(self, buflen=1024, flags=0):\n        self._checkClosed()\n        if self._sslobj is not None:\n            if flags != 0:\n                raise ValueError(\n                    \"non-zero flags not allowed in calls to recv() on %s\" %\n                    self.__class__)\n            return self.read(buflen)\n        else:\n>           return super().recv(buflen, flags)\nE           ConnectionResetError: [Errno 104] Connection reset by peer\n\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/ssl.py:1234: ConnectionResetError",
    "steps" : [ {
      "name" : "Прочитать сообщение",
      "time" : {
        "start" : 1760346127845,
        "stop" : 1760346161117,
        "duration" : 33272
      },
      "status" : "broken",
      "statusMessage" : "ConnectionResetError: [Errno 104] Connection reset by peer\n",
      "statusTrace" : "  File \"/home/runner/work/PulseWave/PulseWave/api_testing/api_base.py\", line 54, in read_email\n    mail = imaplib.IMAP4_SSL('imap.mail.ru')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/imaplib.py\", line 1315, in __init__\n    IMAP4.__init__(self, host, port, timeout)\n  File \"/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/imaplib.py\", line 205, in __init__\n    self.open(host, port, timeout)\n  File \"/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/imaplib.py\", line 1328, in open\n    IMAP4.open(self, host, port, timeout)\n  File \"/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/imaplib.py\", line 315, in open\n    self.sock = self._create_socket(timeout)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/imaplib.py\", line 1319, in _create_socket\n    return self.ssl_context.wrap_socket(sock,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/ssl.py\", line 455, in wrap_socket\n    return self.sslsocket_class._create(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/ssl.py\", line 1004, in _create\n    notconn_pre_handshake_data = self.recv(1)\n                                 ^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/ssl.py\", line 1234, in recv\n    return super().recv(buflen, flags)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
      "steps" : [ ],
      "attachments" : [ ],
      "parameters" : [ ],
      "stepsCount" : 0,
      "attachmentsCount" : 0,
      "shouldDisplayMessage" : true,
      "hasContent" : true
    } ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 1,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : true,
    "hasContent" : true
  },
  "afterStages" : [ ],
  "labels" : [ {
    "name" : "epic",
    "value" : "Тестирование API"
  }, {
    "name" : "tag",
    "value" : "smoke"
  }, {
    "name" : "parentSuite",
    "value" : "tests.api_tests"
  }, {
    "name" : "suite",
    "value" : "api_test"
  }, {
    "name" : "subSuite",
    "value" : "TestAPI"
  }, {
    "name" : "host",
    "value" : "runnervmwhb2z"
  }, {
    "name" : "thread",
    "value" : "2618-MainThread"
  }, {
    "name" : "framework",
    "value" : "pytest"
  }, {
    "name" : "language",
    "value" : "cpython3"
  }, {
    "name" : "package",
    "value" : "tests.api_tests.api_test"
  }, {
    "name" : "resultFormat",
    "value" : "allure2"
  } ],
  "parameters" : [ ],
  "links" : [ ],
  "hidden" : false,
  "retry" : false,
  "extra" : {
    "severity" : "normal",
    "retries" : [ ],
    "categories" : [ {
      "name" : "Test defects",
      "matchedStatuses" : [ ],
      "flaky" : false
    } ],
    "history" : {
      "statistic" : {
        "failed" : 0,
        "broken" : 2,
        "skipped" : 0,
        "passed" : 135,
        "unknown" : 0,
        "total" : 137
      },
      "items" : [ {
        "uid" : "b802136e309201c3",
        "reportUrl" : "https://Nat754.github.io/PulseWave/539//#testresult/b802136e309201c3",
        "status" : "passed",
        "time" : {
          "start" : 1760239983215,
          "stop" : 1760239987898,
          "duration" : 4683
        }
      }, {
        "uid" : "20f2ef334d7a5697",
        "reportUrl" : "https://Nat754.github.io/PulseWave/538//#testresult/20f2ef334d7a5697",
        "status" : "passed",
        "time" : {
          "start" : 1760153079955,
          "stop" : 1760153086329,
          "duration" : 6374
        }
      }, {
        "uid" : "2be6ed1993c6496b",
        "reportUrl" : "https://Nat754.github.io/PulseWave/537//#testresult/2be6ed1993c6496b",
        "status" : "passed",
        "time" : {
          "start" : 1760067114908,
          "stop" : 1760067120860,
          "duration" : 5952
        }
      }, {
        "uid" : "1e7a1a4056fbd95f",
        "reportUrl" : "https://Nat754.github.io/PulseWave/536//#testresult/1e7a1a4056fbd95f",
        "status" : "passed",
        "time" : {
          "start" : 1759980697607,
          "stop" : 1759980703132,
          "duration" : 5525
        }
      }, {
        "uid" : "6a58af92e101117f",
        "reportUrl" : "https://Nat754.github.io/PulseWave/535//#testresult/6a58af92e101117f",
        "status" : "passed",
        "time" : {
          "start" : 1759894198997,
          "stop" : 1759894204327,
          "duration" : 5330
        }
      }, {
        "uid" : "43304fe8014c24c9",
        "reportUrl" : "https://Nat754.github.io/PulseWave/534//#testresult/43304fe8014c24c9",
        "status" : "passed",
        "time" : {
          "start" : 1759807832535,
          "stop" : 1759807837801,
          "duration" : 5266
        }
      }, {
        "uid" : "db5146b47e15e0f8",
        "reportUrl" : "https://Nat754.github.io/PulseWave/533//#testresult/db5146b47e15e0f8",
        "status" : "passed",
        "time" : {
          "start" : 1759721597506,
          "stop" : 1759721602768,
          "duration" : 5262
        }
      }, {
        "uid" : "d806b76cc5af6f75",
        "reportUrl" : "https://Nat754.github.io/PulseWave/532//#testresult/d806b76cc5af6f75",
        "status" : "passed",
        "time" : {
          "start" : 1759635301042,
          "stop" : 1759635305258,
          "duration" : 4216
        }
      }, {
        "uid" : "95d0787f2f4b871b",
        "reportUrl" : "https://Nat754.github.io/PulseWave/531//#testresult/95d0787f2f4b871b",
        "status" : "passed",
        "time" : {
          "start" : 1759548122280,
          "stop" : 1759548127193,
          "duration" : 4913
        }
      }, {
        "uid" : "73fb650a0c8ce2c2",
        "reportUrl" : "https://Nat754.github.io/PulseWave/530//#testresult/73fb650a0c8ce2c2",
        "status" : "passed",
        "time" : {
          "start" : 1759490704206,
          "stop" : 1759490710646,
          "duration" : 6440
        }
      }, {
        "uid" : "99a75008b431c46a",
        "reportUrl" : "https://Nat754.github.io/PulseWave/530//#testresult/99a75008b431c46a",
        "status" : "passed",
        "time" : {
          "start" : 1759462012781,
          "stop" : 1759462018127,
          "duration" : 5346
        }
      }, {
        "uid" : "1c9cc8842c309798",
        "reportUrl" : "https://Nat754.github.io/PulseWave/529//#testresult/1c9cc8842c309798",
        "status" : "passed",
        "time" : {
          "start" : 1759375671199,
          "stop" : 1759375675715,
          "duration" : 4516
        }
      }, {
        "uid" : "ee92d709039aaf44",
        "reportUrl" : "https://Nat754.github.io/PulseWave/528//#testresult/ee92d709039aaf44",
        "status" : "passed",
        "time" : {
          "start" : 1759290100935,
          "stop" : 1759290105919,
          "duration" : 4984
        }
      }, {
        "uid" : "d5dcdde491b656cc",
        "reportUrl" : "https://Nat754.github.io/PulseWave/527//#testresult/d5dcdde491b656cc",
        "status" : "passed",
        "time" : {
          "start" : 1759261429620,
          "stop" : 1759261438477,
          "duration" : 8857
        }
      }, {
        "uid" : "f9d3d2e4005172b7",
        "reportUrl" : "https://Nat754.github.io/PulseWave/527//#testresult/f9d3d2e4005172b7",
        "status" : "passed",
        "time" : {
          "start" : 1759203029217,
          "stop" : 1759203034759,
          "duration" : 5542
        }
      }, {
        "uid" : "519021cc45d543b8",
        "reportUrl" : "https://Nat754.github.io/PulseWave/526//#testresult/519021cc45d543b8",
        "status" : "passed",
        "time" : {
          "start" : 1759116981653,
          "stop" : 1759116985840,
          "duration" : 4187
        }
      }, {
        "uid" : "d10f25f8fcc16295",
        "reportUrl" : "https://Nat754.github.io/PulseWave/525//#testresult/d10f25f8fcc16295",
        "status" : "passed",
        "time" : {
          "start" : 1759030643912,
          "stop" : 1759030650490,
          "duration" : 6578
        }
      }, {
        "uid" : "173f2ffeb814ab9c",
        "reportUrl" : "https://Nat754.github.io/PulseWave/524//#testresult/173f2ffeb814ab9c",
        "status" : "passed",
        "time" : {
          "start" : 1758943616036,
          "stop" : 1758943662142,
          "duration" : 46106
        }
      }, {
        "uid" : "8836ef0401e4b22c",
        "reportUrl" : "https://Nat754.github.io/PulseWave/523//#testresult/8836ef0401e4b22c",
        "status" : "passed",
        "time" : {
          "start" : 1758857490557,
          "stop" : 1758857495391,
          "duration" : 4834
        }
      }, {
        "uid" : "552d172d3638ce6f",
        "reportUrl" : "https://Nat754.github.io/PulseWave/522//#testresult/552d172d3638ce6f",
        "status" : "passed",
        "time" : {
          "start" : 1758771144376,
          "stop" : 1758771150222,
          "duration" : 5846
        }
      } ]
    },
    "tags" : [ "smoke" ]
  },
  "source" : "2ad84850a7e166ba.json",
  "parameterValues" : [ ]
}